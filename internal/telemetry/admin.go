package telemetry

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"time"

	"github.com/vs-ude/btml/internal/structs"
)

// InitConf creates a new bucket and exchanges the admin token from the config for
// a write-only token that will be used to send telemetry data. It replaces the
// values in the Metrics struct for the actual IDs and the write token.
func InitConf(c *structs.TelemetryConf) error {
	if err := getOrgID(c); err != nil {
		return fmt.Errorf("failed to get org ID: %w", err)
	}
	if err := createBucket(c); err != nil {
		return fmt.Errorf("failed to create bucket: %w", err)
	}
	if err := tradeToken(c); err != nil {
		return fmt.Errorf("failed to trade token: %w", err)
	}
	return nil
}

func getOrgID(c *structs.TelemetryConf) error {
	// Setup
	req, err := http.NewRequest("GET", fmt.Sprintf("%s/api/v2/orgs?org=%s", c.URL, c.Org), nil)
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", fmt.Sprintf("Token %s", c.Token))
	slog.Debug("Sending org list request to InfluxDB")

	// Execute
	resp, err := execRequest(req, nil)
	if err != nil {
		return err
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %s", resp.Status)
	}
	defer resp.Body.Close()

	// Decode
	var orgsInfo struct {
		Orgs []struct {
			ID   string `json:"id"`
			Name string `json:"name"`
		} `json:"orgs"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&orgsInfo); err != nil {
		return fmt.Errorf("failed to decode response: %w", err)
	}
	slog.Debug("Received org list response from InfluxDB", "orgs", orgsInfo)
	if len(orgsInfo.Orgs) == 0 {
		return fmt.Errorf("no orgs found")
	}
	c.Org = orgsInfo.Orgs[0].ID
	return nil
}

func createBucket(c *structs.TelemetryConf) error {
	// Setup
	req, err := setupPostRequest(c, "/buckets")
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	body := bytes.NewBuffer([]byte{})
	err = json.Compact(body, fmt.Appendf(nil, `{
			"orgID": "%s",
			"name": "btml-%s"
		}`, c.Org, time.Now().Format("2006-01-02-15-04-05")))
	if err != nil {
		return err
	}
	slog.Debug("Sending bucket create request to InfluxDB", "body", body.String())

	// Execute
	resp, err := execRequest(req, body)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %s", resp.Status)
	}

	// Decode
	var bucket struct {
		ID   string `json:"id"`
		Name string `json:"name"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&bucket); err != nil {
		return fmt.Errorf("failed to decode response: %w", err)
	}
	c.Bucket = bucket.ID
	slog.Debug("Received bucket response from InfluxDB", "bucket", bucket)
	return nil
}

func tradeToken(c *structs.TelemetryConf) error {
	// Setup
	req, err := setupPostRequest(c, "/authorizations")
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}
	body := bytes.NewBuffer([]byte{})
	err = json.Compact(body, fmt.Appendf(nil, `{
			"status": "active",
			"description": "Autogenerated BTML telemetry token",
			"orgID": "%s",
			"permissions": [
				{
					"action": "write",
					"resource": {
						"orgID": "%s",
						"type": "buckets",
						"name": "%s"
					}
				}
			]
		}`, c.Org, c.Org, c.Bucket))
	if err != nil {
		return err
	}
	slog.Debug("Sending token create request to InfluxDB", "body", body.String())

	// Execute
	resp, err := execRequest(req, body)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("unexpected status code: %s", resp.Status)
	}

	// Decode
	var tokenInfo struct {
		Token string `json:"token"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&tokenInfo); err != nil {
		return fmt.Errorf("failed to decode response: %w", err)
	}
	c.Token = tokenInfo.Token
	slog.Debug("Received token response from InfluxDB", "token", tokenInfo.Token)
	return nil
}

func setupPostRequest(c *structs.TelemetryConf, p string) (*http.Request, error) {
	req, err := http.NewRequest("POST", fmt.Sprintf("%s/api/v2%s", c.URL, p), nil)
	if err == nil {
		req.Header.Set("Authorization", fmt.Sprintf("Token %s", c.Token))
		req.Header.Set("Content-Type", "application/json")
	}
	return req, err
}

func execRequest(req *http.Request, body *bytes.Buffer) (*http.Response, error) {
	if body != nil {
		req.Body = io.NopCloser(body)
		req.Header.Set("Content-Length", fmt.Sprintf("%d", body.Len()))
	}

	var resp *http.Response
	var err error
	for range 3 {
		resp, err = http.DefaultClient.Do(req)
		if err == nil {
			break
		}
		time.Sleep(time.Second * 2)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	return resp, nil
}
